window.gpuSortGenerate=function(t){var e={};function o(a){if(e[a])return e[a].exports;var r=e[a]={i:a,l:!1,exports:{}};return t[a].call(r.exports,r,r.exports,o),r.l=!0,r.exports}return o.m=t,o.c=e,o.d=function(t,e,a){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:a})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(o.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)o.d(a,r,function(e){return t[e]}.bind(null,r));return a},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=10)}([function(t,e,o){"use strict";var a;function r(){if(!a)try{const t=document.createElement("canvas");if(!t)throw new Error("unable to create canvas");const e=t.getContext("webgl2");if(e&&"undefined"!=typeof WebGL2RenderingContext)console.debug("your browser supports WebGL2"),a=e;else{console.debug("your browser doesn't support WebGL2");const e=t.getContext("webgl");if(!e)throw new Error("unable to get context");a=e}}catch(t){throw new Error("unable to get WebGL context from canvas")}return a}Object.defineProperty(e,"__esModule",{value:!0}),e.getWebGLContext=r,e.setWebGLContext=function(t){return a=t||r()},e.isWebGL2=function(){return"undefined"!=typeof WebGL2RenderingContext&&r()instanceof WebGL2RenderingContext};var n=0;e.getMaxRenderBufferSize=function(){if(!n){const t=r();n=t.getParameter(t.MAX_RENDERBUFFER_SIZE),console.debug(`MAX_RENDERBUFFER_SIZE: '${n}'`)}return n}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=o(0),r=o(2),n=o(5),l=o(7),i=o(8),s=o(9),f=o(3);t.exports={setWebGLContext:a.setWebGLContext,getWebGLContext:a.getWebGLContext,isWebGL2:a.isWebGL2,ComputeShader:r.ComputeShader,passThruFrag:r.passThruFrag,passThruVert:r.passThruVert,RenderTarget:n.RenderTarget,packBooleans:l.packBooleans,unpackBooleans:l.unpackBooleans,packInt16:i.packInt16,unpackInt16:i.unpackInt16,MIN_INT16:i.MIN_INT16,MAX_INT16:i.MAX_INT16,packUint16:s.packUint16,unpackUint16:s.unpackUint16,MIN_UINT16:s.MIN_UINT16,MAX_UINT16:s.MAX_UINT16,functionStrings:f.functionStrings};var u=o(0);e.setWebGLContext=u.setWebGLContext,e.getWebGLContext=u.getWebGLContext,e.isWebGL2=u.isWebGL2;var d=o(2);e.ComputeShader=d.ComputeShader,e.passThruFrag=d.passThruFrag,e.passThruVert=d.passThruVert;var c=o(5);e.RenderTarget=c.RenderTarget;var h=o(7);e.packBooleans=h.packBooleans,e.unpackBooleans=h.unpackBooleans;var g=o(8);e.packInt16=g.packInt16,e.unpackInt16=g.unpackInt16,e.MIN_INT16=g.MIN_INT16,e.MAX_INT16=g.MAX_INT16;var p=o(9);e.packUint16=p.packUint16,e.unpackUint16=p.unpackUint16,e.MIN_UINT16=p.MIN_UINT16,e.MAX_UINT16=p.MAX_UINT16;var E=o(3);e.functionStrings=E.functionStrings},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=o(0);e.passThruVert="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = vec4(a_position, 1.0);\n}",e.passThruFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_tex;\nuniform float u_textureWidth;\n\nvoid main() {\n  gl_FragColor = texture2D(u_tex, gl_FragCoord.xy / u_textureWidth);\n}";e.ComputeShader=class{constructor(t,o,r,n){n=n?a.setWebGLContext(n):a.getWebGLContext(),this.vertShader=this.createVertShader(this.searchAndReplace(r||e.passThruVert,o)),this.fragShader=this.createFragShader(this.searchAndReplace(t,o)),this.program=this.createProgram(this.vertShader,this.fragShader),this.attributeInfo=this.getAttributeInfo(n,this.program),this.uniformInfo=this.getUniformInfo(n,this.program)}delete(){const t=a.getWebGLContext();t.deleteShader(this.vertShader),t.deleteShader(this.fragShader),t.deleteProgram(this.program)}createVertShader(t){const e=a.getWebGLContext(),o=e.createShader(e.VERTEX_SHADER);if(!o)throw new Error("unable to create new vertex shader");if(e.shaderSource(o,t.trim()),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))throw new Error(`could not compile vertex shader: ${e.getShaderInfoLog(o)}\n\n${t.trim()}`);return o}createFragShader(t){const e=a.getWebGLContext(),o=e.createShader(e.FRAGMENT_SHADER);if(!o)throw new Error("unable to create new fragment shader");if(e.shaderSource(o,t.trim()),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))throw new Error(`could not compile fragment shader: ${e.getShaderInfoLog(o)}\n\n${t.trim()}`);return o}createProgram(t,e){const o=a.getWebGLContext();var r=o.createProgram();if(!r)throw new Error("unable to create program");if(o.attachShader(r,t),o.attachShader(r,e),o.linkProgram(r),!o.getProgramParameter(r,o.LINK_STATUS))throw new Error(`error in program linking: ${o.getProgramInfoLog(r)}`);return r}searchAndReplace(t,e){if(e)for(var[o,a]of Object.entries(e))t=t.replace(o,a);return t}getAttributeInfo(t,e){const o={},a=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<a;r++){const a=t.getActiveAttrib(e,r);if(null===a)continue;const n=t.getAttribLocation(e,a.name);null!==n&&(o[a.name]={size:a.size,type:a.type,location:n})}return o}getUniformInfo(t,e){const o={},a=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let r=0;r<a;r++){const a=t.getActiveUniform(e,r);if(null===a)continue;const n=t.getUniformLocation(e,a.name);null!==n&&(o[a.name]={size:a.size,type:a.type,location:n})}return o}}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.round="\nfloat round(float f) {\n  return floor(f + 0.5);\n}".trim(),e.floatEquals="\nfloat floatEquals(float f1, float f2) {\n  return 1.0 - abs(sign(f1 - f2));\n}".trim(),e.floatNotEquals="\nfloat floatNotEquals(float f1, float f2) {\n  return abs(sign(f1 - f2));\n}".trim(),e.floatLessThan="\nfloat floatLessThan(float f1, float f2) {\n  return max(sign(f2 - f1), 0.0);\n}".trim(),e.floatGreaterThan="\nfloat floatGreaterThan(float f1, float f2) {\n  return max(sign(f1 - f2), 0.0);\n}".trim(),e.floatLessThanOrEqual="\nfloat floatLessThanOrEqual(float f1, float f2) {\n  return 1.0 - floatGreaterThan(f1, f2);\n}".trim(),e.floatGreaterThanOrEqual="\nfloat floatGreaterThanOrEqual(float f1, float f2) {\n  return 1.0 - floatLessThan(f1, f2);\n}".trim(),e.vec2ToInt16="\nfloat vec2ToInt16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0) - 32767.0, -32767.0, 32768.0);\n}".trim(),e.int16ToVec2="\nvec2 int16ToVec2(float f) {\n  f = clamp(f, -32767.0, 32768.0) + 32767.0; \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),e.vec2ToUint16="\nfloat vec2ToUint16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0), 0.0, 65535.0);\n}".trim(),e.uint16ToVec2="\nvec2 uint16ToVec2(float f) {\n  f = clamp(f, 0.0, 65535.0); \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),e.unpackBooleans="\nvoid unpackBooleans(float f, inout bool arr[8]) {\n  f = floor(f * 255.0);\n  arr[0] = bool(int(floatGreaterThanOrEqual(f, 128.0)));\n  f -= floatGreaterThanOrEqual(f, 128.0) * 128.0;\n  arr[1] = bool(int(floatGreaterThanOrEqual(f, 64.0)));\n  f -= floatGreaterThanOrEqual(f, 64.0) * 64.0;\n  arr[2] = bool(int(floatGreaterThanOrEqual(f, 32.0)));\n  f -= floatGreaterThanOrEqual(f, 32.0) * 32.0;\n  arr[3] = bool(int(floatGreaterThanOrEqual(f, 16.0)));\n  f -= floatGreaterThanOrEqual(f, 16.0) * 16.0;\n  arr[4] = bool(int(floatGreaterThanOrEqual(f, 8.0)));\n  f -= floatGreaterThanOrEqual(f, 8.0) * 8.0;\n  arr[5] = bool(int(floatGreaterThanOrEqual(f, 4.0)));\n  f -= floatGreaterThanOrEqual(f, 4.0) * 4.0;\n  arr[6] = bool(int(floatGreaterThanOrEqual(f, 2.0)));\n  f -= floatGreaterThanOrEqual(f, 2.0) * 2.0;\n  arr[7] = bool(int(floatGreaterThanOrEqual(f, 1.0)));\n}".trim(),e.packBooleans="\nfloat packBooleans(bool arr[8]) {\n  float f = float(int(arr[0])) * 128.0;\n  f += float(int(arr[1])) * 64.0;\n  f += float(int(arr[2])) * 32.0;\n  f += float(int(arr[3])) * 16.0;\n  f += float(int(arr[4])) * 8.0;\n  f += float(int(arr[5])) * 4.0;\n  f += float(int(arr[6])) * 2.0;\n  return (f + float(int(arr[7]))) / 255.0;\n}".trim(),e.functionStrings={round:e.round,floatEquals:e.floatEquals,floatNotEquals:e.floatNotEquals,floatLessThan:e.floatLessThan,floatGreaterThan:e.floatGreaterThan,floatLessThanOrEqual:e.floatLessThanOrEqual,floatGreaterThanOrEqual:e.floatGreaterThanOrEqual,vec2ToInt16:e.vec2ToInt16,int16ToVec2:e.int16ToVec2,vec2ToUint16:e.vec2ToUint16,uint16ToVec2:e.uint16ToVec2,unpackBooleans:e.unpackBooleans,packBooleans:e.packBooleans}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getTransform64Shader=c,e.getSort64Shader=h,e.getUntransform64Shader=g,e.getTransform32Shader=p,e.getSort32Shader=E,e.getUntransform32Shader=m,e.initializeShaders=function(){c(),h(),g(),p(),E(),m()},e.searchAndReplace=void 0;var a=function(t){if(t&&t.__esModule)return t;var e=r();if(e&&e.has(t))return e.get(t);var o={};if(null!=t){var a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var l=a?Object.getOwnPropertyDescriptor(t,n):null;l&&(l.get||l.set)?Object.defineProperty(o,n,l):o[n]=t[n]}}o.default=t,e&&e.set(t,o);return o}(o(1));function r(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return r=function(){return t},t}const n={"float round(float);":a.functionStrings.round,"float floatEquals(float, float);":a.functionStrings.floatEquals,"float floatNotEquals(float, float);":a.functionStrings.floatNotEquals,"float floatLessThan(float, float);":a.functionStrings.floatLessThan,"float floatGreaterThan(float, float);":a.functionStrings.floatGreaterThan,"float floatLessThanOrEqual(float, float);":a.functionStrings.floatLessThanOrEqual,"float floatGreaterThanOrEqual(float, float);":a.functionStrings.floatGreaterThanOrEqual,"float vec2ToUint16(vec2);":a.functionStrings.vec2ToUint16,"vec2 uint16ToVec2(float);":a.functionStrings.uint16ToVec2};e.searchAndReplace=n;var l,i,s;var f,u,d;function c(){return l||(l=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_mode;\nuniform float u_endianness;\nuniform float u_dataDelimX;\nuniform float u_dataDelimY;\n\nconst float PASSTHROUGH = 0.0;\nconst float INTEGER = 1.0;\nconst float FLOAT = 2.0;\n\nconst float LITTLE_ENDIAN = 0.0;\nconst float BIG_ENDIAN = 1.0;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// get current texel\n\tvec2 baseFragCoord = vec2(floor(gl_FragCoord.x) - mod(floor(gl_FragCoord.x), 2.0), floor(gl_FragCoord.y)); \n\tvec4 texelOne = texture2D(u_bytes, vec2(baseFragCoord.xy + vec2(0.5, 0.5)) / u_width);\n\tvec4 texelTwo = texture2D(u_bytes, vec2(baseFragCoord.xy + vec2(1.5, 0.5)) / u_width);\n\n\t// reorder if endianness if not little endian\n\tvec4 reorderedOne = floatEquals(u_endianness, LITTLE_ENDIAN) * texelOne.rgba\n                      + floatEquals(u_endianness, BIG_ENDIAN) * texelTwo.abgr;\n\tvec4 reorderedTwo = floatEquals(u_endianness, LITTLE_ENDIAN) * texelTwo.rgba\n                      + floatEquals(u_endianness, BIG_ENDIAN) * texelOne.abgr;\n\n\t// denormalize texel data\n\ttexelOne = 255.0 * reorderedOne;\n\ttexelTwo = 255.0 * reorderedTwo;\n\n\t// initialize flipped texel\n\tvec4 flippedOne = floatEquals(u_mode, PASSTHROUGH) * texelOne.rgba;\n\tvec4 flippedTwo = floatEquals(u_mode, PASSTHROUGH) * texelTwo.rgba;\n\n\t// determine if we should flip the bits or not\n\tfloat signBitIsSet = floatGreaterThanOrEqual(floor(texelTwo.a), 128.0);\n\n\t// for integers just flip the sign bit\n\tflippedOne.r += floatEquals(u_mode, INTEGER) * texelOne.r;\n\tflippedOne.g += floatEquals(u_mode, INTEGER) * texelOne.g;\n\tflippedOne.b += floatEquals(u_mode, INTEGER) * texelOne.b;\n\tflippedOne.a += floatEquals(u_mode, INTEGER) * texelOne.a;\n\tflippedTwo.r += floatEquals(u_mode, INTEGER) * texelTwo.r;\n\tflippedTwo.g += floatEquals(u_mode, INTEGER) * texelTwo.g;\n\tflippedTwo.b += floatEquals(u_mode, INTEGER) * texelTwo.b;\n\tflippedTwo.a += floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 0.0) * (texelTwo.a + 128.0)\n\t\t\t\t  + floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 1.0) * (texelTwo.a - 128.0);\n\n\t// for floats flip only sign bit if the sign bit WAS NOT not already set - otherwise flip all of the bits\n\tflippedOne.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelOne.r\n\t\t\t\t  + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelOne.r);\n\tflippedOne.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelOne.g\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelOne.g);\n\tflippedOne.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelOne.b\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelOne.b);\n\tflippedOne.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelOne.a\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelOne.a);\n\tflippedTwo.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelTwo.r\n\t\t\t\t  + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelTwo.r);\n\tflippedTwo.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelTwo.g\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelTwo.g);\n\tflippedTwo.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texelTwo.b\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelTwo.b);\n\tflippedTwo.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (texelTwo.a + 128.0)\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texelTwo.a);\n\n\t// output denormalized bytes\n\tgl_FragColor = floatEquals(floor(mod(floor(gl_FragCoord.x), 2.0)), 0.0) * (flippedOne.rgba / 255.0)\n\t\t\t\t + floatEquals(floor(mod(floor(gl_FragCoord.x), 2.0)), 1.0) * (flippedTwo.rgba / 255.0);\n\n    // zeroize all out of bounds data\n    gl_FragColor *= max(floatLessThan(floor(gl_FragCoord.x), u_dataDelimX), \n                        floatLessThan(floor(gl_FragCoord.y), u_dataDelimY));\n    gl_FragColor *= floatLessThanOrEqual(floor(gl_FragCoord.y), u_dataDelimY);\n}",n)),l}function h(){return i||(i=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_blockSizeX;\nuniform float u_blockSizeY;\nuniform float u_regionSizeX;\nuniform float u_regionSizeY;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// double the blockSize area\n\tfloat dblBlockSizeY = u_blockSizeY + u_blockSizeY * floatEquals(u_blockSizeX, u_width);\n\tfloat dblBlockSizeX = u_blockSizeX + u_blockSizeX * floatLessThan(u_blockSizeX, u_width);\n\n\t// calculate starting coordinates for this block\n\tvec2 blockStartCoord  = vec2(gl_FragCoord.x - floor(mod(floor(gl_FragCoord.x), dblBlockSizeX)),\n\t\t\t\t\t\t\t\t gl_FragCoord.y - floor(mod(floor(gl_FragCoord.y), dblBlockSizeY)));\n\tvec2 blockOffset      = vec2(floatEquals(dblBlockSizeY, 1.0) * dblBlockSizeX, floatGreaterThan(dblBlockSizeY, 1.0) * dblBlockSizeY);\n\tvec2 halfBlockOffset  = vec2(floatEquals(blockOffset.y, 0.0) * blockOffset.x / 2.0 +\n\t\t\t\t\t\t\t\t floatEquals(blockOffset.y, 1.0) * floatEquals(blockOffset.x, 0.0) * u_width / 2.0, \n\t\t\t\t\t\t\t\t floor(blockOffset.y / 2.0));\n\tvec2 blockMiddleCoord = vec2(blockStartCoord.xy) + halfBlockOffset;\n\n\t// double the regionSize area\n\tfloat dblRegionSizeY = u_regionSizeY + u_regionSizeY * floatEquals(u_regionSizeX, u_width);\n\tfloat dblRegionSizeX = u_regionSizeX + u_regionSizeX * floatLessThan(u_regionSizeX, u_width);\n\n\t// calculate starting coordinates for each sorting region\n\tvec2 ascendingStartCoord  = vec2(gl_FragCoord.x - floor(mod(floor(gl_FragCoord.x), dblRegionSizeX)),\n\t\t\t\t\t\t\t\t\t gl_FragCoord.y - floor(mod(floor(gl_FragCoord.y), dblRegionSizeY)));\n\tvec2 regionOffset         = vec2(floatEquals(dblRegionSizeY, 1.0) * dblRegionSizeX, floatGreaterThan(dblRegionSizeY, 1.0) * dblRegionSizeY);\n\tvec2 halfRegionOffset     = vec2(floatEquals(regionOffset.y, 0.0) * regionOffset.x / 2.0 +\n\t\t\t\t\t\t\t\t\t floatEquals(regionOffset.y, 1.0) * floatEquals(regionOffset.x, 0.0) * u_width / 2.0, \n\t\t\t\t\t\t\t\t\t floor(regionOffset.y / 2.0));\n\tvec2 descendingStartCoord = vec2(ascendingStartCoord.xy) + halfRegionOffset;\n\n\t// get booleans for determining relative position and sorting order\n\tfloat ascendingGroupBool = floatLessThan(floor(gl_FragCoord.y), floor(descendingStartCoord.y));\n\tascendingGroupBool      += floatEquals(floor(gl_FragCoord.y), floor(descendingStartCoord.y)) * \n\t\t\t\t\t\t       floatLessThan(floor(gl_FragCoord.x), floor(descendingStartCoord.x));\t\t   \n\tfloat firstTexelBool     = floatLessThan(floor(gl_FragCoord.y), floor(blockMiddleCoord.y));\n\tfirstTexelBool          += floatEquals(floor(gl_FragCoord.y), floor(blockMiddleCoord.y)) * \n\t\t\t\t\t           floatLessThan(floor(gl_FragCoord.x), floor(blockMiddleCoord.x));\n\n\t// get current data\n\tvec2 localDataCoord = vec2(floor(gl_FragCoord.x) - mod(floor(gl_FragCoord.x), 2.0), gl_FragCoord.y);\n\tvec4 localDataOne = texture2D(u_bytes, vec2(localDataCoord.xy + vec2(0.5, 0.0)) / u_width);\n\tvec4 localDataTwo = texture2D(u_bytes, vec2(localDataCoord.xy + vec2(1.5, 0.0)) / u_width);\n\n\t// get peer data\n\tvec2 peerFragCoord = floatEquals(firstTexelBool, 1.0) * (localDataCoord.xy + halfBlockOffset)\n\t\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * (localDataCoord.xy - halfBlockOffset);\n\tvec4 peerDataOne = texture2D(u_bytes, vec2(peerFragCoord.xy + vec2(0.5, 0.0)) / u_width);\n\tvec4 peerDataTwo = texture2D(u_bytes, vec2(peerFragCoord.xy + vec2(1.5, 0.0)) / u_width);\n\t\n\t// create alpha and bravo texels where alpha is expected to be less than bravo\n\tvec4 alphaDataOne = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * localDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * peerDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * peerDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * localDataOne.rgba;\n\tvec4 alphaDataTwo = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * localDataTwo.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * peerDataTwo.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * peerDataTwo.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * localDataTwo.rgba;\n\tvec4 bravoDataOne = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * peerDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * localDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * localDataOne.rgba\n\t\t\t\t      + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * peerDataOne.rgba;\n\tvec4 bravoDataTwo = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * peerDataTwo.rgba\n\t\t\t\t\t  + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * localDataTwo.rgba\n\t\t\t\t\t  + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * localDataTwo.rgba\n\t\t\t\t\t  + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * peerDataTwo.rgba;\n\n\t// denormalize data\n\talphaDataOne *= 255.0;\n\talphaDataTwo *= 255.0;\n\tbravoDataOne *= 255.0;\n\tbravoDataTwo *= 255.0;\n\n\t// initializing booleans to false\n\tfloat swapBool = 0.0;\n\tfloat notSwapBool = 0.0;\n\n\t// compare each byte in order to determine if swap is necessary\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataTwo.a), round(bravoDataTwo.a));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataTwo.a), round(bravoDataTwo.a));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataTwo.b), round(bravoDataTwo.b));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataTwo.b), round(bravoDataTwo.b));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataTwo.g), round(bravoDataTwo.g));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataTwo.g), round(bravoDataTwo.g));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataTwo.r), round(bravoDataTwo.r));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataTwo.r), round(bravoDataTwo.r));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataOne.a), round(bravoDataOne.a));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataOne.a), round(bravoDataOne.a));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataOne.b), round(bravoDataOne.b));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataOne.b), round(bravoDataOne.b));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataOne.g), round(bravoDataOne.g));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataOne.g), round(bravoDataOne.g));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaDataOne.r), round(bravoDataOne.r));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaDataOne.r), round(bravoDataOne.r));\n\n\t// handle edge case where bytes are identical and thus both booleans are false\n\tnotSwapBool += floatEquals(notSwapBool, 0.0) * floatEquals(swapBool, 0.0);\n\n\t// use booleans to render the correct texel\n\tgl_FragColor = floatEquals(notSwapBool, 1.0) * floatEquals(mod(floor(gl_FragCoord.x), 2.0), 0.0) * localDataOne.rgba\n\t\t\t\t + floatEquals(notSwapBool, 1.0) * floatEquals(mod(floor(gl_FragCoord.x), 2.0), 1.0) * localDataTwo.rgba\n\t\t\t\t + floatEquals(notSwapBool, 0.0) * floatEquals(mod(floor(gl_FragCoord.x), 2.0), 0.0) * peerDataOne.rgba\n\t\t\t\t + floatEquals(notSwapBool, 0.0) * floatEquals(mod(floor(gl_FragCoord.x), 2.0), 1.0) * peerDataTwo.rgba;\n}\n",n)),i}function g(){return s||(s=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_mode;\nuniform float u_endianness;\n\nconst float PASSTHROUGH = 0.0;\nconst float INTEGER = 1.0;\nconst float FLOAT = 2.0;\n\nconst float LITTLE_ENDIAN = 0.0;\nconst float BIG_ENDIAN = 1.0;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// get current texel\n\tvec2 baseFragCoord = vec2(floor(gl_FragCoord.x) - mod(floor(gl_FragCoord.x), 2.0), floor(gl_FragCoord.y)); \n\tvec4 texelOne = texture2D(u_bytes, vec2(baseFragCoord.xy + vec2(0.5, 0.5)) / u_width);\n\tvec4 texelTwo = texture2D(u_bytes, vec2(baseFragCoord.xy + vec2(1.5, 0.5)) / u_width);\n\n\t// reorder if endianness if not little endian\n\tvec4 reorderedOne = floatEquals(u_endianness, LITTLE_ENDIAN) * texelOne.rgba\n                      + floatEquals(u_endianness, BIG_ENDIAN) * texelTwo.abgr;\n\tvec4 reorderedTwo = floatEquals(u_endianness, LITTLE_ENDIAN) * texelTwo.rgba\n                      + floatEquals(u_endianness, BIG_ENDIAN) * texelOne.abgr;\n\n\t// denormalize texel data\n\ttexelOne = 255.0 * reorderedOne;\n\ttexelTwo = 255.0 * reorderedTwo;\n\n\t// initialize flipped texel\n\tvec4 flippedOne = floatEquals(u_mode, PASSTHROUGH) * texelOne.rgba;\n\tvec4 flippedTwo = floatEquals(u_mode, PASSTHROUGH) * texelTwo.rgba;\n\n\t// determine if we should flip the bits or not\n\tfloat signBitIsSet = floatGreaterThanOrEqual(floor(texelTwo.a), 128.0);\n\n\t// for integers just flip the sign bit\n\tflippedOne.r += floatEquals(u_mode, INTEGER) * texelOne.r;\n\tflippedOne.g += floatEquals(u_mode, INTEGER) * texelOne.g;\n\tflippedOne.b += floatEquals(u_mode, INTEGER) * texelOne.b;\n\tflippedOne.a += floatEquals(u_mode, INTEGER) * texelOne.a;\n\tflippedTwo.r += floatEquals(u_mode, INTEGER) * texelTwo.r;\n\tflippedTwo.g += floatEquals(u_mode, INTEGER) * texelTwo.g;\n\tflippedTwo.b += floatEquals(u_mode, INTEGER) * texelTwo.b;\n\tflippedTwo.a += floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 0.0) * (texelTwo.a + 128.0)\n\t\t\t\t  + floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 1.0) * (texelTwo.a - 128.0);\n\n\t// NOTE: to untransform floats we must invert the logic seen in `transform.frag`\n\t// for floats flip only sign bit if the sign bit WAS already set - otherwise flip all of the bits\n\tflippedOne.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelOne.r\n\t\t\t\t  + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelOne.r);\n\tflippedOne.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelOne.g\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelOne.g);\n\tflippedOne.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelOne.b\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelOne.b);\n\tflippedOne.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelOne.a\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelOne.a);\n\tflippedTwo.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelTwo.r\n\t\t\t\t  + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelTwo.r);\n\tflippedTwo.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelTwo.g\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelTwo.g);\n\tflippedTwo.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texelTwo.b\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelTwo.b);\n\tflippedTwo.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (texelTwo.a - 128.0)\n\t\t\t      + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texelTwo.a);\n\n\t// output denormalized bytes\n\tgl_FragColor = floatEquals(floor(mod(floor(gl_FragCoord.x), 2.0)), 0.0) * (flippedOne.rgba / 255.0)\n\t\t\t\t + floatEquals(floor(mod(floor(gl_FragCoord.x), 2.0)), 1.0) * (flippedTwo.rgba / 255.0);\n}",n)),s}function p(){return f||(f=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_mode;\nuniform float u_endianness;\nuniform float u_dataDelimX;\nuniform float u_dataDelimY;\n\nconst float PASSTHROUGH = 0.0;\nconst float INTEGER = 1.0;\nconst float FLOAT = 2.0;\n\nconst float LITTLE_ENDIAN = 0.0;\nconst float BIG_ENDIAN = 1.0;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// get current texel\n\tvec4 texel = texture2D(u_bytes, vec2(gl_FragCoord.xy) / u_width);\n\n\t// reorder if endianness if not little endian\n\tvec4 reordered = floatEquals(u_endianness, LITTLE_ENDIAN) * texel.rgba\n                   + floatEquals(u_endianness, BIG_ENDIAN) * texel.abgr;\n\n\t// denormalize texel data\n\ttexel = 255.0 * reordered;\n\n\t// initialize flipped texel\n\tvec4 flipped = floatEquals(u_mode, PASSTHROUGH) * texel.rgba;\n\n\t// determine if we should flip the bits or not\n\tfloat signBitIsSet = floatGreaterThanOrEqual(floor(texel.a), 128.0);\n\n\t// for integers just flip the sign bit\n\tflipped.r += floatEquals(u_mode, INTEGER) * texel.r;\n\tflipped.g += floatEquals(u_mode, INTEGER) * texel.g;\n\tflipped.b += floatEquals(u_mode, INTEGER) * texel.b;\n\tflipped.a += floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 0.0) * (texel.a + 128.0)\n\t\t\t   + floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 1.0) * (texel.a - 128.0);\n\n\t// for floats flip only sign bit if the sign bit WAS NOT already set - otherwise flip all of the bits\n\tflipped.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texel.r\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texel.r);\n\tflipped.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texel.g\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texel.g);\n\tflipped.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * texel.b\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texel.b);\n\tflipped.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (texel.a + 128.0)\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (255.0 - texel.a);\n\n\t// output denormalized bytes\n\tgl_FragColor = flipped.rgba / 255.0;\n\n    // zeroize all out of bounds data\n    gl_FragColor *= max(floatLessThan(floor(gl_FragCoord.x), u_dataDelimX), \n                        floatLessThan(floor(gl_FragCoord.y), u_dataDelimY));\n    gl_FragColor *= floatLessThanOrEqual(floor(gl_FragCoord.y), u_dataDelimY);\n}",n)),f}function E(){return u||(u=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_blockSizeX;\nuniform float u_blockSizeY;\nuniform float u_regionSizeX;\nuniform float u_regionSizeY;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// calculate starting coordinates for this block\n\tvec2 blockStartCoord  = vec2(gl_FragCoord.x - floor(mod(floor(gl_FragCoord.x), u_blockSizeX)),\n\t\t\t\t\t\t\t\t gl_FragCoord.y - floor(mod(floor(gl_FragCoord.y), u_blockSizeY)));\n\tvec2 blockOffset      = vec2(floatEquals(u_blockSizeY, 1.0) * u_blockSizeX, floatGreaterThan(u_blockSizeY, 1.0) * u_blockSizeY);\n\tvec2 halfBlockOffset  = vec2(floatEquals(blockOffset.y, 0.0) * blockOffset.x / 2.0 +\n\t\t\t\t\t\t\t\t floatEquals(blockOffset.y, 1.0) * floatEquals(blockOffset.x, 0.0) * u_width / 2.0, \n\t\t\t\t\t\t\t\t floor(blockOffset.y / 2.0));\n\tvec2 blockMiddleCoord = vec2(blockStartCoord.xy) + halfBlockOffset;\n\n\t// calculate starting coordinates for each sorting region\n\tvec2 ascendingStartCoord  = vec2(gl_FragCoord.x - floor(mod(floor(gl_FragCoord.x), u_regionSizeX)),\n\t\t\t\t\t\t\t\t\t gl_FragCoord.y - floor(mod(floor(gl_FragCoord.y), u_regionSizeY)));\n\tvec2 regionOffset         = vec2(floatEquals(u_regionSizeY, 1.0) * u_regionSizeX, floatGreaterThan(u_regionSizeY, 1.0) * u_regionSizeY);\n\tvec2 halfRegionOffset     = vec2(floatEquals(regionOffset.y, 0.0) * regionOffset.x / 2.0 +\n\t\t\t\t\t\t\t\t\t floatEquals(regionOffset.y, 1.0) * floatEquals(regionOffset.x, 0.0) * u_width / 2.0, \n\t\t\t\t\t\t\t\t\t floor(regionOffset.y / 2.0));\n\tvec2 descendingStartCoord = vec2(ascendingStartCoord.xy) + halfRegionOffset;\n\n\t// get booleans for determining relative position and sorting order\n\tfloat ascendingGroupBool = floatLessThan(floor(gl_FragCoord.y), floor(descendingStartCoord.y));\n\tascendingGroupBool      += floatEquals(floor(gl_FragCoord.y), floor(descendingStartCoord.y)) *\n\t\t\t\t\t\t       floatLessThan(floor(gl_FragCoord.x), floor(descendingStartCoord.x));\n    float firstTexelBool     = floatLessThan(floor(gl_FragCoord.y), floor(blockMiddleCoord.y));\n\tfirstTexelBool          += floatEquals(floor(gl_FragCoord.y), floor(blockMiddleCoord.y)) * \n                               floatLessThan(floor(gl_FragCoord.x), floor(blockMiddleCoord.x));\n\n\t// get current data\n\tvec4 localData = texture2D(u_bytes, vec2(gl_FragCoord.xy) / u_width);\n\n\t// get peer data\n\tvec2 peerFragCoord = floatEquals(firstTexelBool, 1.0) * (gl_FragCoord.xy + halfBlockOffset)\n\t\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * (gl_FragCoord.xy - halfBlockOffset);\n\tvec4 peerData = texture2D(u_bytes, vec2(peerFragCoord.xy) / u_width);\n\n\t// create alpha and bravo texels where alpha is expected to be less than bravo\n\tvec4 alphaData = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * localData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * peerData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * peerData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * localData.rgba;\n\tvec4 bravoData = floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 1.0) * peerData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 1.0) * floatEquals(ascendingGroupBool, 0.0) * localData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 1.0) * localData.rgba\n\t\t\t\t   + floatEquals(firstTexelBool, 0.0) * floatEquals(ascendingGroupBool, 0.0) * peerData.rgba;\n\n\t// denormalize data\n\talphaData *= 255.0;\n\tbravoData *= 255.0;\n\n\t// initializing booleans to false\n\tfloat swapBool = 0.0;\n\tfloat notSwapBool = 0.0;\n\n\t// compare each byte in order to determine if swap is necessary\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaData.a), round(bravoData.a));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaData.a), round(bravoData.a));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaData.b), round(bravoData.b));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaData.b), round(bravoData.b));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaData.g), round(bravoData.g));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaData.g), round(bravoData.g));\n\tswapBool    += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatGreaterThan(round(alphaData.r), round(bravoData.r));\n\tnotSwapBool += floatEquals(swapBool, 0.0) * floatEquals(notSwapBool, 0.0) * floatLessThan(round(alphaData.r), round(bravoData.r));\n\n\t// handle edge case where bytes are identical and thus both booleans are false\n\tnotSwapBool += floatEquals(notSwapBool, 0.0) * floatEquals(swapBool, 0.0);\n\n\t// use booleans to render the correct texel\n\tgl_FragColor = floatEquals(notSwapBool, 1.0) * localData.rgba\n\t\t\t\t + floatEquals(notSwapBool, 0.0) * peerData.rgba;\n}\n",n)),u}function m(){return d||(d=new a.ComputeShader("#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_bytes;\nuniform float u_width;\nuniform float u_mode;\nuniform float u_endianness;\n\nconst float PASSTHROUGH = 0.0;\nconst float INTEGER = 1.0;\nconst float FLOAT = 2.0;\n\nconst float LITTLE_ENDIAN = 0.0;\nconst float BIG_ENDIAN = 1.0;\n\nfloat round(float);\nfloat floatEquals(float, float);\nfloat floatLessThan(float, float);\nfloat floatGreaterThan(float, float);\nfloat floatLessThanOrEqual(float, float);\nfloat floatGreaterThanOrEqual(float, float);\n\nvoid main() {\n\t// get current texel\n\tvec4 texel = texture2D(u_bytes, vec2(gl_FragCoord.xy) / u_width);\n\n\t// reorder if endianness if not little endian\n\tvec4 reordered = floatEquals(u_endianness, LITTLE_ENDIAN) * texel.rgba \n                   + floatEquals(u_endianness, BIG_ENDIAN) * texel.abgr;\n\n\t// denormalize texel data\n\ttexel = 255.0 * reordered;\n\n\t// initialize flipped texel\n\tvec4 flipped = floatEquals(u_mode, PASSTHROUGH) * texel.rgba;\n\n\t// determine if we should flip the bits or not\n\tfloat signBitIsSet = floatGreaterThanOrEqual(floor(texel.a), 128.0);\n\n\t// for integers just flip the sign bit\n\tflipped.r += floatEquals(u_mode, INTEGER) * texel.r;\n\tflipped.g += floatEquals(u_mode, INTEGER) * texel.g;\n\tflipped.b += floatEquals(u_mode, INTEGER) * texel.b;\n\tflipped.a += floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 0.0) * (texel.a + 128.0)\n\t\t\t   + floatEquals(u_mode, INTEGER) * floatEquals(signBitIsSet, 1.0) * (texel.a - 128.0);\n\n\t// NOTE: to untransform floats we must invert the logic seen in `transform.frag`\n\t// for floats flip only sign bit if the sign bit WAS already set - otherwise flip all of the bits\n\tflipped.r += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texel.r\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texel.r);\n\tflipped.g += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texel.g\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texel.g);\n\tflipped.b += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * texel.b\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texel.b);\n\tflipped.a += floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 1.0) * (texel.a - 128.0)\n\t\t\t   + floatEquals(u_mode, FLOAT) * floatEquals(signBitIsSet, 0.0) * (255.0 - texel.a);\n\n\t// output denormalized bytes\n\tgl_FragColor = flipped.rgba / 255.0;\n}",n)),d}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=o(0),r=o(12),n=o(6);e.RenderTarget=class{constructor(t){const e=a.getMaxRenderBufferSize();if(!Number.isInteger(t)||t<1||t>e)throw new Error(`ComputeTarget width of '${t}' is out of range (1 to ${e})`);if(Math.log(t)/Math.log(2)%1!=0)throw new Error(`ComputeTarget width of '${t}' is not a power of two`);this.width=t,this.targetAlpha=this.createTarget()}compute(t,e){const o=a.getWebGLContext();return o.useProgram(t.program),this.setBuffers(t,n.getComputeBufferInfo()),e&&this.setUniforms(t,e),o.bindFramebuffer(o.FRAMEBUFFER,this.targetAlpha.framebuffer),o.viewport(0,0,this.width,this.width),o.drawArrays(o.TRIANGLES,0,6),this}transpose(t){if(t.width!==this.width)throw new Error(`scatterFragCoord width: '${t.width}' != RenderTarget width: '${this.width}'`);const e=a.getWebGLContext(),o=r.getTransposeShader();return e.useProgram(o.program),this.setBuffers(o,r.getTransposeBufferInfo(this.width)),this.setUniforms(o,{u_scatterCoord:t,u_sourceTex:this,u_textureWidth:this.width}),e.bindFramebuffer(e.FRAMEBUFFER,this.targetAlpha.framebuffer),e.viewport(0,0,this.width,this.width),e.drawArrays(e.POINTS,0,this.width*this.width),this}pushSomePixels(t,e,o,r,n){if(n.length!==o*r*4)throw new Error(`out.length !== ${o*r*4}`);const l=a.getWebGLContext();l.bindTexture(l.TEXTURE_2D,this.targetAlpha.texture),l.texSubImage2D(l.TEXTURE_2D,0,t,e,o,r,l.RGBA,l.UNSIGNED_BYTE,n),l.bindTexture(l.TEXTURE_2D,null)}pushPixelsRecursively(t,e,o,a,r,n,l){const i=Math.min(Math.max(Math.floor(r/o),1),a);if(this.pushSomePixels(t,e,o,i,n.subarray(0,4*o*i)),a-i<=0)return l();requestAnimationFrame(()=>this.pushPixelsRecursively(t,e+i,o,a-i,r,n.subarray(4*o*i),l))}pushSomePixelsAsync(t,e,o,a,r){return new Promise((n,l)=>{if(r.length!==o*a*4)return l(new Error(`out.length !== ${o*a*4}`));this.pushPixelsRecursively(t,e,o,a,262144,r,()=>n())})}pushTextureData(t){const e=this.width,o=t.length/4,a=4*(o-o%e);if(t.length>4*e*e)throw new Error(`array length of: '${t.length}' overflows: '${4*e*e}'`);if(t.length%4>0)throw new Error(`array length of: '${t.length}' is not a multiple of four`);if(e>=o)return this.pushSomePixels(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),t);this.pushSomePixels(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),t.subarray(0,a)),4*e*e>t.length&&this.pushSomePixels(0,Math.floor(o/e),o%e,1,t.subarray(a))}pushTextureDataAsync(t){return new Promise((e,o)=>{const a=this.width,r=t.length/4,n=4*(r-r%a);return t.length>4*a*a?o(new Error(`array length of: '${t.length}' overflows: '${4*a*a}'`)):t.length%4>0?o(new Error(`array length of: '${t.length}' is not a multiple of four`)):void(a>=r?this.pushSomePixelsAsync(0,0,Math.min(r,a),Math.max(Math.floor(r/a),1),t).then(()=>e()).catch(t=>o(t)):4*a*a>t.length?this.pushSomePixelsAsync(0,0,Math.min(r,a),Math.max(Math.floor(r/a),1),t.subarray(0,n)).then(()=>this.pushSomePixelsAsync(0,Math.floor(r/this.width),r%this.width,1,t.subarray(n)).then(()=>e()).catch(t=>o(t))).catch(t=>o(t)):this.pushSomePixelsAsync(0,0,Math.min(r,a),Math.max(Math.floor(r/a),1),t.subarray(0,n)).then(()=>e()).catch(t=>o(t)))})}readPixels(t){return this.readSomePixels(0,0,this.width,this.width,t)}readPixelsAsync(t){return this.readSomePixelsAsync(0,0,this.width,this.width,t)}readSomePixels(t,e,o,r,n){n||(n=new Uint8Array(o*r*4));const l=a.getWebGLContext();return l.bindFramebuffer(l.FRAMEBUFFER,this.targetAlpha.framebuffer),l.readPixels(t,e,o,r,l.RGBA,l.UNSIGNED_BYTE,n),l.bindFramebuffer(l.FRAMEBUFFER,null),n}readPixelsRecursively(t,e,o,a,r,n,l){const i=Math.min(Math.max(Math.floor(r/o),1),a);if(this.readSomePixels(t,e,o,i,n.subarray(0,4*o*i)),a-i<=0)return l();requestAnimationFrame(()=>this.readPixelsRecursively(t,e+i,o,a-i,r,n.subarray(4*o*i),l))}readSomePixelsAsync(t,e,o,a,r){return new Promise((n,l)=>{if(r||(r=new Uint8Array(o*a*4)),r.length!==o*a*4)return l(new Error(`out.length !== ${o*a*4}`));this.readPixelsRecursively(t,e,o,a,262144,r,()=>n(r))})}delete(){const t=a.getWebGLContext();t.deleteTexture(this.targetAlpha.texture),t.deleteFramebuffer(this.targetAlpha.framebuffer),this.targetBravo&&(t.deleteTexture(this.targetBravo.texture),t.deleteFramebuffer(this.targetBravo.framebuffer))}deleteBackBuffer(){if(this.targetBravo){const t=a.getWebGLContext();t.deleteTexture(this.targetBravo.texture),t.deleteFramebuffer(this.targetBravo.framebuffer)}}setBuffers(t,e){const o=a.getWebGLContext();for(var r in e){const a=e[r].buffer,n=e[r].numComponents,l=t.attributeInfo[r].location;o.bindBuffer(o.ARRAY_BUFFER,a),o.enableVertexAttribArray(l),o.vertexAttribPointer(l,n,o.FLOAT,!1,0,0),o.bindBuffer(o.ARRAY_BUFFER,null)}}setUniforms(t,e){const o=a.getWebGLContext();let r=0,n=!1;for(let a in t.uniformInfo){const l=e[a],i=t.uniformInfo[a].type,s=t.uniformInfo[a].location;switch(i){case o.SAMPLER_2D:if(Array.isArray(l)||"number"==typeof l)throw new Error(`provided uniform: '${a}' is not a WebGLTexture`);o.uniform1i(s,r),o.activeTexture(o.TEXTURE0+r++),n||this!==l?o.bindTexture(o.TEXTURE_2D,l.targetAlpha.texture):(this.targetBravo||(this.targetBravo=this.createTarget()),[this.targetAlpha,this.targetBravo]=[this.targetBravo,this.targetAlpha],n=!0,o.bindTexture(o.TEXTURE_2D,this.targetBravo.texture));break;case o.FLOAT:"number"==typeof l?o.uniform1f(s,l):Array.isArray(l)&&o.uniform1fv(s,l);break;case o.FLOAT_VEC2:case o.FLOAT_VEC3:case o.FLOAT_VEC4:throw new Error("uniform vectors are currently unsupported");default:throw new Error(`unsupported uniform type: '${i}'`)}}}createTarget(){const t=a.getWebGLContext(),e=t.createFramebuffer();if(!e)throw new Error("unable to create framebuffer");const o=t.createTexture();if(!o)throw new Error("unable to create texture");return t.bindFramebuffer(t.FRAMEBUFFER,e),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.width,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),{framebuffer:e,texture:o}}}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=o(0);function r(t){const e=a.getWebGLContext(),o={};for(let a in t){const r=e.createBuffer();if(null===r)throw new Error("unable to create buffer");o[a]={buffer:r,numComponents:t[a].numComponents}}for(let a in o)e.bindBuffer(e.ARRAY_BUFFER,o[a].buffer),e.bufferData(e.ARRAY_BUFFER,t[a].data,e.STATIC_DRAW);return e.bindBuffer(e.ARRAY_BUFFER,null),o}var n;e.createBufferInfoFromArrays=r,e.getComputeBufferInfo=function(){return n||(n=r({a_position:{data:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),numComponents:2}})),n}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.unpackBooleans=function(t){var e=new Array(8);t=Math.min(Math.max(0,Math.round(t)),255);for(var o=0;o<8;o++){var a=Math.pow(2,7-o);t>=a?(e[o]=!0,t-=a):e[o]=!1}return e},e.packBooleans=function(t){for(var e=0,o=0;o<8;o++)t.length>o&&t[o]&&(e+=Math.pow(2,7-o));return e}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.MAX_INT16=32768,e.MIN_INT16=-32767,e.unpackInt16=function(t,e){return 256*(t=Math.min(Math.max(0,Math.floor(t)),255))+(e=Math.min(Math.max(0,Math.floor(e)),255))-32767},e.packInt16=function(t){var e=new Array(2);return t=Math.min(Math.max(-32767,Math.round(t)),32768)+32767,e[0]=Math.floor(t/256),e[1]=t-256*e[0],e}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.MAX_UINT16=65535,e.MIN_UINT16=0,e.unpackUint16=function(t,e){return 256*(t=Math.min(Math.max(0,Math.floor(t)),255))+(e=Math.min(Math.max(0,Math.floor(e)),255))},e.packUint16=function(t){var e=new Array(2);return t=Math.min(Math.max(0,Math.round(t)),65535),e[0]=Math.floor(t/256),e[1]=t-256*e[0],e}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isBenchmarking=function(){return i},e.startBenchmarking=m,e.getBenchmarkText=b,e.default=void 0;var a=function(t){if(t&&t.__esModule)return t;var e=r();if(e&&e.has(t))return e.get(t);var o={};if(null!=t){var a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var l=a?Object.getOwnPropertyDescriptor(t,n):null;l&&(l.get||l.set)?Object.defineProperty(o,n,l):o[n]=t[n]}}o.default=t,e&&e.set(t,o);return o}(o(11));function r(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return r=function(){return t},t}function n(t,e,o,a,r,n,l){try{var i=t[n](l),s=i.value}catch(t){return void o(t)}i.done?e(s):Promise.resolve(s).then(a,r)}function l(t){return function(){var e=this,o=arguments;return new Promise((function(a,r){var l=t.apply(e,o);function i(t){n(l,a,r,i,s,"next",t)}function s(t){n(l,a,r,i,s,"throw",t)}i(void 0)}))}}var i=!1;const s=[256,512,1024,2048,4096],f=new Array(3*s.length).fill("pending");function u(t){0}function d(t){const e=new Float64Array(Array.from(Array(t*t/2),()=>Math.random()-.5));let o=performance.now();return a.sort(e),u(),performance.now()-o}function c(t){return new Promise(e=>{const o=new Float64Array(t*t/2);!function t(e,o,a){for(let t=0;t<1e5;t++)o[e++]=Math.random()-.5;if(e>=o.length)return a();requestAnimationFrame(()=>t(e,o,a))}(0,o,()=>{let t=performance.now();a.sortAsync(o).then(()=>{u(),e(performance.now()-t)})})})}function h(t){const e=new Float64Array(Array.from(Array(t*t/2),()=>Math.random()-.5));let o=performance.now();return e.sort((t,e)=>t-e),performance.now()-o}function g(){return p.apply(this,arguments)}function p(){return(p=l((function*(){a.initializeShaders(),d(s[0]),yield c(s[0]),h(s[0])}))).apply(this,arguments)}function E(t){return Math.round(t).toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")}function m(){return T.apply(this,arguments)}function T(){return(T=l((function*(){if(!i){i=!0,f.fill("pending"),yield g();for(let t=0;t<s.length;t++){const e=d(s[t]);f[t+0*s.length]=`${E(e)}ms`,yield new Promise(t=>setTimeout(t,500))}for(let t=0;t<s.length;t++){const e=yield c(s[t]);f[t+1*s.length]=`${E(e)}ms`,yield new Promise(t=>setTimeout(t,500))}for(let t=0;t<s.length;t++){const e=h(s[t]);f[t+2*s.length]=`${E(e)}ms`,yield new Promise(t=>setTimeout(t,500))}i=!1}}))).apply(this,arguments)}function b(){return`‎‎‎\n           32,768\ngpu.sort            ${f[0]}\ngpu.sortAsync       ${f[5]}\nFloat64Array.sort   ${f[10]}\n\n           131,072\ngpu.sort            ${f[1]}\ngpu.sortAsync       ${f[6]}\nFloat64Array.sort   ${f[11]}\n\n           524,288\ngpu.sort            ${f[2]}\ngpu.sortAsync       ${f[7]}\nFloat64Array.sort   ${f[12]}\n\n          2,097,152\ngpu.sort            ${f[3]}\ngpu.sortAsync       ${f[8]}\nFloat64Array.sort   ${f[13]}\n\n          8,388,608\ngpu.sort            ${f[4]}\ngpu.sortAsync       ${f[9]}\nFloat64Array.sort   ${f[14]}\n\t`.trim()}var _={startBenchmarking:m,getBenchmarkText:b,isBenchmarking:()=>i};e.default=_},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"initializeShaders",{enumerable:!0,get:function(){return a.initializeShaders}}),Object.defineProperty(e,"setWebGLContext",{enumerable:!0,get:function(){return r.setWebGLContext}}),Object.defineProperty(e,"sort",{enumerable:!0,get:function(){return n.sort}}),Object.defineProperty(e,"sortAsync",{enumerable:!0,get:function(){return n.sortAsync}});var a=o(4),r=o(1),n=o(13);t.exports={initializeShaders:a.initializeShaders,setWebGLContext:r.setWebGLContext,sort:n.sort,sortAsync:n.sortAsync}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=o(0),r=o(6),n=o(2),l=o(3);e.passThruTransposeVert="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_scatterCoord;\nuniform sampler2D u_sourceTex;\nuniform float u_textureWidth;\nattribute vec2 a_position;\nvarying vec4 v_sourceTexel;\n\nfloat vec2ToUint16(vec2 v);\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec4 destinationTexel = texture2D(u_scatterCoord, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n  vec2 destinationCoord = vec2(vec2ToUint16(destinationTexel.rg) + 0.5, vec2ToUint16(destinationTexel.ba) + 0.5);\n  gl_Position = vec4(2.0 * (destinationCoord.xy / u_textureWidth) - vec2(1.0, 1.0), 0.0, 1.0);\n  v_sourceTexel = texture2D(u_sourceTex, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n}",e.passThruTransposeFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nvarying vec4 v_sourceTexel;\n\nvoid main() {\n  gl_FragColor = v_sourceTexel;\n}";const i=new Array(13);var s;e.getTransposeBufferInfo=function(t){if(t<2||t>4096)throw new Error(`width of '${t}' is out of range (2 to 4096)`);const e=Math.log(t)/Math.log(2);if(e%1!=0)throw new Error(`width of '${t}' is not a power of two`);if(!i[e]){const t=Math.pow(2,e),l=new Float32Array(2*t*t);for(var o=0,a=0;a<t;a++)for(var n=0;n<t;n++)l[o++]=2*(n+.5)/t-1,l[o++]=2*(a+.5)/t-1;const s=r.createBufferInfoFromArrays({a_position:{data:l,numComponents:2}});i[e]=s}return i[e]},e.getTransposeShader=function(){if(s)return s;const t=a.getWebGLContext(),o=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);if(o<2)throw new Error(`MAX_VERTEX_TEXTURE_IMAGE_UNITS: '${o}' is less than 2`);const r={"float vec2ToUint16(vec2 v);":l.functionStrings.vec2ToUint16};return s=new n.ComputeShader(e.passThruTransposeFrag,r,e.passThruTransposeVert)}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sort=function(t){if(!t.length)return t;switch(Object.prototype.toString.call(t)){case"[object Int8Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Int16Array]":case"[object Uint16Array]":return t.sort((t,e)=>t-e);case"[object Int32Array]":return(0,a.bitonicSort)(t,"Int32Array");case"[object Uint32Array]":return(0,a.bitonicSort)(t,"Uint32Array");case"[object Float32Array]":return(0,a.bitonicSort)(t,"Float32Array");case"[object Float64Array]":return(0,a.bitonicSort)(t,"Float64Array");case"[object BigInt64Array]":return(0,a.bitonicSort)(t,"BigInt64Array");case"[object BigUint64Array]":return(0,a.bitonicSort)(t,"BigUint64Array")}throw new Error(`${Object.prototype.toString.call(t)} is unsupported`)},e.sortAsync=function(t){return new Promise((e,o)=>{if(!t.length)return e();switch(Object.prototype.toString.call(t)){case"[object Int8Array]":return(0,r.radixSortSignedAsync)(new Uint8Array(t.buffer),256).then(()=>e(t)).catch(t=>o(t));case"[object Uint8Array]":case"[object Uint8ClampedArray]":return(0,r.radixSortAsync)(new Uint8Array(t.buffer),256).then(()=>e(t)).catch(t=>o(t));case"[object Int16Array]":return(0,r.radixSortSignedAsync)(new Uint16Array(t.buffer),65536).then(()=>e(t)).catch(t=>o(t));case"[object Uint16Array]":return(0,r.radixSortAsync)(t,65536).then(()=>e(t)).catch(t=>o(t));case"[object Int32Array]":return(0,a.bitonicSortAsync)(t,"Int32Array").then(()=>e(t)).catch(t=>o(t));case"[object Uint32Array]":return(0,a.bitonicSortAsync)(t,"Uint32Array").then(()=>e(t)).catch(t=>o(t));case"[object Float32Array]":return(0,a.bitonicSortAsync)(t,"Float32Array").then(()=>e(t)).catch(t=>o(t));case"[object Float64Array]":return(0,a.bitonicSortAsync)(t,"Float64Array").then(()=>e(t)).catch(t=>o(t));case"[object BigInt64Array]":return(0,a.bitonicSortAsync)(t,"BigInt64Array").then(()=>e(t)).catch(t=>o(t));case"[object BigUint64Array]":return(0,a.bitonicSortAsync)(t,"BigUint64Array").then(()=>e(t)).catch(t=>o(t))}o(new Error(`${Object.prototype.toString.call(t)} is unsupported`))})};var a=o(14),r=o(18)},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.bitonicSort=function(t,e){const o=new Uint8Array(t.buffer),a=f(o);a.pushTextureData(o);const r=a.width*a.width-o.length/4,l=new n.BitonicUniformGenerator(a,e,r);for(let t of l.generate())a.compute(t.shader,t.uniforms);return u(a,r,o),a.delete(),t},e.bitonicSortAsync=function(t,e){return new Promise((o,a)=>{const l=new Uint8Array(t.buffer),i=f(l);i.pushTextureDataAsync(l).then(()=>{const t=new r.Limiter(i.width),s=i.width*i.width-l.length/4,f=new n.BitonicUniformGenerator(i,e,s);for(let e of f.generate())t.addWork(()=>i.compute(e.shader,e.uniforms));t.onceFinished(()=>{d(i,s,l).then(()=>o()).catch(t=>a(t)).finally(()=>(i.delete(),t.stop()))})}).catch(t=>(a(t),i.delete()))})},e.getRenderTarget=f,e.pullPixels=u,e.pullPixelsAsync=d;var a=function(t){if(t&&t.__esModule)return t;var e=l();if(e&&e.has(t))return e.get(t);var o={};if(null!=t){var a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=a?Object.getOwnPropertyDescriptor(t,r):null;n&&(n.get||n.set)?Object.defineProperty(o,r,n):o[r]=t[r]}}o.default=t,e&&e.set(t,o);return o}(o(1)),r=o(15),n=o(16);function l(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return l=function(){return t},t}function i(t,e,o,a,r,n,l){try{var i=t[n](l),s=i.value}catch(t){return void o(t)}i.done?e(s):Promise.resolve(s).then(a,r)}function s(t){return function(){var e=this,o=arguments;return new Promise((function(a,r){var n=t.apply(e,o);function l(t){i(n,a,r,l,s,"next",t)}function s(t){i(n,a,r,l,s,"throw",t)}l(void 0)}))}}function f(t){const e=a.getWebGLContext(),o=e.getParameter(e.MAX_RENDERBUFFER_SIZE);for(let e=1;e<=o;e*=2)if(e*e*4>=t.length)return new a.RenderTarget(e);throw new Error(`data overflows ${o}x${o} framebuffer`)}function u(t,e,o){const a=t.width,r=Math.floor(e/a);e%a>0?(t.readSomePixels(e%a,r,a-e%a,1,o.subarray(0,4*(a-e%a))),t.readSomePixels(0,r+1,a,a-r-1,o.subarray(4*(a-e%a)))):t.readSomePixels(0,r,a,a-r,o)}function d(t,e,o){return c.apply(this,arguments)}function c(){return(c=s((function*(t,e,o){const a=t.width,r=Math.floor(e/a);return e%a>0?(yield t.readSomePixelsAsync(e%a,r,a-e%a,1,o.subarray(0,4*(a-e%a))),t.readSomePixelsAsync(0,r+1,a,a-r-1,o.subarray(4*(a-e%a)))):t.readSomePixelsAsync(0,r,a,a-r,o)}))).apply(this,arguments)}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Limiter=void 0;var a=o(1);function r(t,e,o){return e in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}e.Limiter=class{constructor(t){r(this,"stopped",!1),r(this,"tally",0),r(this,"rate",void 0),r(this,"work",[]),this.rate=t>=4096?1:2048===t?4:1024===t?16:128,this.executeWork()}stop(){this.stopped=!0}executeWork(){if(this.tally+=this.rate,0===this.work.length)return this.tally=Math.max(this.tally,1),void(this.stopped||requestAnimationFrame(()=>this.executeWork()));if(this.tally>=1){const t=Math.floor(Math.min(this.work.length,Math.max(this.rate,1)));for(let e=0;e<t;e++)this.work[e]();this.work.splice(0,t),this.tally-=t}(0,a.getWebGLContext)().flush(),requestAnimationFrame(()=>this.executeWork())}addWork(t){if(this.stopped)throw new Error("limiter has been stopped");this.work.push(t)}onceFinished(t){const e=()=>{this.work.length?requestAnimationFrame(()=>e()):t()};e()}}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BitonicUniformGenerator=e.isLittleEndian=e.isBigEndian=void 0;var a=o(17);function r(t,e,o){return e in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}const n=18===new Uint8Array(new Uint32Array([305419896]).buffer)[0];e.isBigEndian=n;const l=120===new Uint8Array(new Uint32Array([305419896]).buffer)[0];e.isLittleEndian=l;e.BitonicUniformGenerator=class{constructor(t,e,o){r(this,"target",void 0),r(this,"parameters",void 0),r(this,"emptyTexelCount",void 0),this.target=t,this.parameters=(0,a.getBitonicParameters)(e),this.emptyTexelCount=o}*generate(){for(let t of this.generateTransformerUniforms())yield{shader:this.parameters.transformShader,uniforms:t};for(let t of this.generateSorterUniforms())yield{shader:this.parameters.sortShader,uniforms:t};for(let t of this.generateUntransformerUniforms())yield{shader:this.parameters.untransformShader,uniforms:t}}*generateTransformerUniforms(){if(!l||this.parameters.mode!==a.TRANSFORM_MODE.PASSTHROUGH){const t=this.target.width,e=t*t-this.emptyTexelCount;yield{u_bytes:this.target,u_width:t,u_mode:this.parameters.mode,u_endianness:l?0:1,u_dataDelimX:Math.floor(e%t),u_dataDelimY:Math.floor(e/t)}}}*generateSorterUniforms(){const t=this.target.width;for(let e=4;e<=2*t*t;e*=2)for(let o=e/2;o>1;o/=2)yield{u_bytes:this.target,u_width:t,u_blockSizeX:Math.floor(o%t)>0?Math.floor(o%t):t,u_blockSizeY:Math.max(Math.floor(o/t),1),u_regionSizeX:Math.floor(e%t)>0?Math.floor(e%t):t,u_regionSizeY:Math.max(Math.floor(e/t),1)}}*generateUntransformerUniforms(){l&&this.parameters.mode===a.TRANSFORM_MODE.PASSTHROUGH||(yield{u_bytes:this.target,u_width:this.target.width,u_mode:this.parameters.mode,u_endianness:l?0:1})}}},function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getBitonicParameters=function(t){switch(t){case"Int32Array":return{mode:n.INTEGER,constructor:l.Int32Array,transformShader:a.getTransform32Shader(),sortShader:a.getSort32Shader(),untransformShader:a.getUntransform32Shader()};case"Uint32Array":return{mode:n.PASSTHROUGH,constructor:l.Uint32Array,transformShader:a.getTransform32Shader(),sortShader:a.getSort32Shader(),untransformShader:a.getUntransform32Shader()};case"Float32Array":return{mode:n.FLOAT,constructor:l.Float32Array,transformShader:a.getTransform32Shader(),sortShader:a.getSort32Shader(),untransformShader:a.getUntransform32Shader()};case"Float64Array":return{mode:n.FLOAT,constructor:l.Float64Array,transformShader:a.getTransform64Shader(),sortShader:a.getSort64Shader(),untransformShader:a.getUntransform64Shader()};case"BigInt64Array":return{mode:n.INTEGER,constructor:l.BigInt64Array,transformShader:a.getTransform64Shader(),sortShader:a.getSort64Shader(),untransformShader:a.getUntransform64Shader()};case"BigUint64Array":return{mode:n.PASSTHROUGH,constructor:l.BigUint64Array,transformShader:a.getTransform64Shader(),sortShader:a.getSort64Shader(),untransformShader:a.getUntransform64Shader()}}throw new Error(`unsupported constructor.name: ${t}`)},e.CONSTRUCTOR_MODE=e.TRANSFORM_MODE=void 0;var a=function(t){if(t&&t.__esModule)return t;var e=r();if(e&&e.has(t))return e.get(t);var o={};if(null!=t){var a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var l=a?Object.getOwnPropertyDescriptor(t,n):null;l&&(l.get||l.set)?Object.defineProperty(o,n,l):o[n]=t[n]}}o.default=t,e&&e.set(t,o);return o}(o(4));function r(){if("function"!=typeof WeakMap)return null;var t=new WeakMap;return r=function(){return t},t}let n,l;e.TRANSFORM_MODE=n,function(t){t[t.PASSTHROUGH=0]="PASSTHROUGH",t[t.INTEGER=1]="INTEGER",t[t.FLOAT=2]="FLOAT"}(n||(e.TRANSFORM_MODE=n={})),e.CONSTRUCTOR_MODE=l,function(t){t[t.Int32Array=0]="Int32Array",t[t.Uint32Array=1]="Uint32Array",t[t.Float32Array=2]="Float32Array",t[t.Float64Array=3]="Float64Array",t[t.BigInt64Array=4]="BigInt64Array",t[t.BigUint64Array=5]="BigUint64Array"}(l||(e.CONSTRUCTOR_MODE=l={}))},function(t,e,o){"use strict";function a(t,e,o,r){const n=Date.now();for(;o<e.length;)if(t[e[o++]]++,!(o%65536)&&Date.now()-n>1e3/90)return void requestAnimationFrame(()=>a(t,e,o,r));r()}function r(t,e,o,a,n){const l=Date.now();for(;o<e.length&&a<t.length;)if(e.fill(a,o,o+=t[a++]),Date.now()-l>1e3/90)return void requestAnimationFrame(()=>r(t,e,o,a,n));n(o)}Object.defineProperty(e,"__esModule",{value:!0}),e.radixSortAsync=function(t,e){return new Promise(o=>{const n=new Array(e).fill(0);a(n,t,0,()=>{r(n,t,0,0,()=>{o()})})})},e.radixSortSignedAsync=function(t,e){return new Promise(o=>{const n=new Array(e).fill(0);a(n,t,0,()=>{r(n,t,0,e/2,e=>{r(n,t,e,0,()=>{o()})})})})}}]);